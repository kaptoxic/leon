/* Copyright 2009-2013 EPFL, Lausanne */

package leon
package smtlib

import solvers.IncrementalSolver
import utils.Interruptible
import purescala._
import Common._
import Trees._
import Extractors._
import TreeOps._
import TypeTrees._
import Definitions._

import _root_.smtlib.{PrettyPrinter => CommandPrinter, Commands, CommandResponses, sexpr, Interpreter => SMTLIBInterpreter}
import Commands.{Identifier => SMTLIBIdentifier, _}
import CommandResponses.{Error => ErrorResponse, _}
import sexpr.SExprs._
import _root_.smtlib.Commands.{Identifier => SmtLibIdentifier, _}


class SMTLIBSolver(override val context: LeonContext, 
                   val program: Program, 
                   smtlibInterpreterFactory: () => SMTLIBInterpreter) 
  extends IncrementalSolver with Interruptible {

  override def interrupt: Unit = {}
  override def recoverInterrupt(): Unit = {}


  override def name: String = "smtlib-solver"
  val out = new java.io.FileWriter("vcs/vc_" + SMTLIBSolver.counter)

  //using a factory, so that creation and call to free are local to this class
  private val smtlibInterpreter = smtlibInterpreterFactory()

  private var errorConstants: Set[(SSymbol, SExpr)] = Set()

  val defs: Seq[ClassTypeDef] = program.definedClasses

  val partition: Seq[(AbstractClassDef, Seq[CaseClassDef])] = {
    val parents: Seq[AbstractClassDef] = defs.filter(!_.hasParent).asInstanceOf[Seq[AbstractClassDef]]
    parents.map(p => (p, defs.filter(c => c.parent match {
      case Some(p2) => p == p2
      case None => false
    }).asInstanceOf[Seq[CaseClassDef]]))
  }

  val sorts: Seq[SExpr] = partition.map{ case (parent, children) => {
    val name = id2sym(parent.id)
    val constructors: List[SExpr] = children.map(child => {
      val fields: List[SExpr] = child.fields.map{case VarDecl(id, tpe) => SList(id2sym(id), tpe2sort(tpe)) }.toList
      if(fields.isEmpty) id2sym(child.id) else SList(id2sym(child.id) :: fields)
    }).toList

    SList(name :: constructors)
  }}
  val constructors: Map[String, CaseClassDef] = 
    partition.unzip._2.flatMap(ccds => ccds.map(ccd => (ccd.id.uniqueName.toUpperCase, ccd))).toMap
  val sortDecls = NonStandardCommand(SList(SSymbol("declare-datatypes"), SList(), SList(sorts.toList)))
  val funDefDecls: Seq[Command] = program.definedFunctions.flatMap(fd2sexp)
  val sortErrors: List[Command] = errorConstants.map(p => DeclareFun(p._1.s, Seq(), p._2)).toList

  def declareConst(id: Identifier): Command = DeclareFun(id2sym(id).s, Seq(), tpe2sort(id.getType))

    //SComment("! THEORY=1") +:
    //SComment("Generated by Leon") +:
  sendCommand(sortDecls)
  sortErrors.foreach(sendCommand(_)) 
  funDefDecls.foreach(sendCommand)

      //convertedFunDefs.flatMap(_._1) ++
      //convertedFunDefs.map(_._2) ++
      //convertedFunDefs.flatMap(_._3) ++
      //Seq(SList(SSymbol("check-sat")))

  private var freeVars: Set[Identifier] = program.definedFunctions.flatMap(fd => fd.args.map(_.id)).toSet
  override def assertCnstr(expression: Expr): Unit = {

    val (sexpr, exprFreevars) = ExprToSExpr(expression)

    val newFreeVars: Set[Identifier] = exprFreevars.diff(freeVars)
    freeVars ++= newFreeVars
    newFreeVars.foreach(id => sendCommand(declareConst(id)))

    sendCommand(Assert(sexpr))
  }

  override def check: Option[Boolean] = sendCommand(CheckSat) match {
    case CheckSatResponse(SatStatus) => Some(true)
    case CheckSatResponse(UnsatStatus) => Some(false)
    case CheckSatResponse(UnknownStatus) => None
  }

  override def getModel: Map[Identifier, Expr] = {
    val ids: List[Identifier] = freeVars.toList
    val sexprs: List[SSymbol] = ids.map(id => id2sym(id))
    val cmd: Command = GetValue(sexprs.head, sexprs.tail)

    val symToIds: Map[SExpr, Identifier] = sexprs.map(s => SSymbol(s.s.toUpperCase)).zip(ids).toMap
    val GetValueResponse(valuationPairs) = sendCommand(cmd)
    println("got valuation pairs: " + valuationPairs)
    valuationPairs.map{ case (sym, value) => (symToIds(sym), SExprToExpr(value, Map(), constructors)) }.toMap
  }

  override def free() = {
    sendCommand(Exit)
    smtlibInterpreter.free()
    out.close
    SMTLIBSolver.counter += 1
  }

  override def push(): Unit = {
    sendCommand(Push(1))
  }
  override def pop(lvl: Int = 1): Unit = {
    sendCommand(Pop(1))
  }

  def sendCommand(cmd: Command): CommandResponse = {
    val startTime = System.currentTimeMillis
    CommandPrinter(cmd, out)
    out.write("\n")
    val response = smtlibInterpreter.eval(cmd)
    assert(!response.isInstanceOf[Error])
    SMTLIBSolver.time = SMTLIBSolver.time + (System.currentTimeMillis - startTime)
    response
  }

  private def fd2sexp(funDef: FunDef): List[Command] = {
    val name = id2sym(funDef.id)
    val returnSort = tpe2sort(funDef.returnType)

    val varDecls: List[(SSymbol, SExpr)] = funDef.args.map(vd => (id2sym(vd.id), tpe2sort(vd.tpe))).toList

    val topLevelVarDecl: List[Command] = varDecls.map{ case (name, tpe) => DeclareFun(name.s, Seq(), tpe) }
    val funDecl: Command = DeclareFun(name.s, varDecls.map(_._2), returnSort)

    funDecl :: topLevelVarDecl
  }
}

object SMTLIBSolver {
  var counter = 0
  var time: Long = 0
}
